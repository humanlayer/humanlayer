---
description: 透過徹底研究與更新來迭代現有實作計畫
model: opus
---

# 迭代實作計畫

您的任務是根據使用者回饋更新現有的實作計畫。您應該抱持懷疑態度、徹底,並確保變更基於實際的程式碼庫現實。

## 初始回應

當此指令被執行時:

1. **解析輸入以識別**:
   - 計畫檔案路徑(例如:`thoughts/shared/plans/2025-10-16-feature.md`)
   - 請求的變更/回饋

2. **處理不同的輸入情境**:

   **如果未提供計畫檔案**:
   ```
   我將協助您迭代現有的實作計畫。

   您想要更新哪個計畫?請提供計畫檔案的路徑(例如:`thoughts/shared/plans/2025-10-16-feature.md`)。

   提示: 您可以使用 `ls -lt thoughts/shared/plans/ | head` 列出最近的計畫
   ```
   等待使用者輸入,然後重新檢查回饋。

   **如果提供了計畫檔案但未提供回饋**:
   ```
   我已找到位於 [path] 的計畫。您想要做什麼變更?

   例如:
   - 「新增處理遷移的階段」
   - 「更新成功準則以包含效能測試」
   - 「調整範圍以排除功能 X」
   - 「將階段 2 拆分為兩個獨立階段」
   ```
   等待使用者輸入。

   **如果同時提供了計畫檔案和回饋**:
   - 立即繼續至步驟 1
   - 不需要初步問題

## 流程步驟

### 步驟 1: 讀取並理解目前計畫

1. **完整讀取現有計畫檔案**:
   - 使用 Read 工具時「不要」使用 limit/offset 參數
   - 理解目前的結構、階段和範圍
   - 記錄成功準則和實作方法

2. **理解請求的變更**:
   - 解析使用者想要新增/修改/移除的內容
   - 識別變更是否需要程式碼庫研究
   - 確定更新的範圍

### 步驟 2: 必要時進行研究

**只有在變更需要新的技術理解時才產生研究任務。**

如果使用者的回饋需要理解新的程式碼模式或驗證假設:

1. **建立研究待辦清單**,使用 TodoWrite

2. **產生並行子任務進行研究**:
   針對每種研究類型使用正確的代理:

   **對於程式碼調查:**
   - **codebase-locator** - 尋找相關檔案
   - **codebase-analyzer** - 理解實作細節
   - **codebase-pattern-finder** - 尋找類似模式

   **對於歷史脈絡:**
   - **thoughts-locator** - 尋找相關的研究或決策
   - **thoughts-analyzer** - 從文件中提取見解

   **對目錄要「極其」明確**:
   - 如果變更涉及「WUI」,請指定 `humanlayer-wui/` 目錄
   - 如果涉及「daemon」,請指定 `hld/` 目錄
   - 在提示中包含完整路徑上下文

3. **讀取研究識別的任何新檔案**:
   - 將它們完整讀入主要上下文
   - 與計畫需求交叉參照

4. **等待所有子任務完成**後再繼續

### 步驟 3: 呈現理解與方法

在進行變更前,確認您的理解:

```
根據您的回饋,我了解您想要:
- [具體細節的變更 1]
- [具體細節的變更 2]

我的研究發現:
- [相關的程式碼模式或限制條件]
- [影響變更的重要發現]

我計畫透過以下方式更新計畫:
1. [要進行的特定修改]
2. [另一個修改]

這是否符合您的意圖?
```

在繼續前獲得使用者確認。

### 步驟 4: 更新計畫

1. **對現有計畫進行聚焦、精確的編輯**:
   - 使用 Edit 工具進行精準變更
   - 除非明確變更,否則維持現有結構
   - 保持所有 file:line 參考準確
   - 必要時更新成功準則

2. **確保一致性**:
   - 如果新增新階段,確保遵循現有模式
   - 如果修改範圍,更新「我們不做的事情」章節
   - 如果變更方法,更新「實作方法」章節
   - 維持自動化與手動成功準則的區分

3. **保持品質標準**:
   - 為新內容包含特定的檔案路徑和行號
   - 撰寫可測量的成功準則
   - 對自動化驗證使用 `make` 指令
   - 保持語言清晰且可執行

### 步驟 5: 同步與審查

1. **同步更新的計畫**:
   - 執行 `humanlayer thoughts sync`
   - 這確保變更被正確索引

2. **呈現所做的變更**:
   ```
   我已更新位於 `thoughts/shared/plans/[filename].md` 的計畫

   所做的變更:
   - [特定變更 1]
   - [特定變更 2]

   更新後的計畫現在:
   - [關鍵改進]
   - [另一個改進]

   您是否需要進一步調整?
   ```

3. **準備根據回饋進一步迭代**

## 重要指引

1. **保持懷疑**:
   - 不要盲目接受看似有問題的變更請求
   - 質疑模糊的回饋 - 尋求澄清
   - 透過程式碼研究驗證技術可行性
   - 指出與現有計畫階段的潛在衝突

2. **保持精準**:
   - 進行精確編輯,而非全面重寫
   - 保留不需要變更的優質內容
   - 只研究特定變更所需的內容
   - 不要過度設計更新

3. **保持徹底**:
   - 在進行變更前讀取整個現有計畫
   - 如果變更需要新的技術理解,則研究程式碼模式
   - 確保更新的章節維持品質標準
   - 驗證成功準則仍然可測量

4. **保持互動**:
   - 在進行變更前確認理解
   - 在執行前展示您計畫變更的內容
   - 允許調整方向
   - 不要在沒有溝通的情況下消失於研究中

5. **追蹤進度**:
   - 如果複雜則使用 TodoWrite 追蹤更新任務
   - 完成研究時更新待辦事項
   - 完成時標記任務

6. **無開放性問題**:
   - 如果請求的變更引發問題,請詢問
   - 立即研究或獲得澄清
   - 「不要」在有未解決問題的情況下更新計畫
   - 每個變更都必須完整且可執行

## 成功準則指引

更新成功準則時,始終維持兩類結構:

1. **自動化驗證**(可由執行代理執行):
   - 可執行的指令: `make test`、`npm run lint` 等
   - 偏好 `make` 指令: `make -C humanlayer-wui check` 而非 `cd humanlayer-wui && bun run fmt`
   - 應該存在的特定檔案
   - 程式碼編譯/型別檢查

2. **手動驗證**(需要人工測試):
   - UI/UX 功能
   - 真實條件下的效能
   - 難以自動化的邊界情況
   - 使用者驗收準則

## 子任務產生最佳實踐

產生研究子任務時:

1. **只有在真正需要時才產生** - 不要為簡單變更進行研究
2. **並行產生多個任務**以提高效率
3. **每個任務應該專注**於特定領域
4. **提供詳細指示**包括:
   - 確切要搜尋的內容
   - 要專注的目錄
   - 要提取的資訊
   - 預期的輸出格式
5. **要求回應中包含特定的 file:line 參考**
6. **等待所有任務完成**後再進行整合
7. **驗證子任務結果** - 如果有問題,產生後續任務

## 互動流程範例

**情境 1: 使用者預先提供所有資訊**
```
使用者: /iterate_plan thoughts/shared/plans/2025-10-16-feature.md - 新增錯誤處理階段
助理: [讀取計畫,研究錯誤處理模式,更新計畫]
```

**情境 2: 使用者只提供計畫檔案**
```
使用者: /iterate_plan thoughts/shared/plans/2025-10-16-feature.md
助理: 我已找到該計畫。您想要做什麼變更?
使用者: 將階段 2 拆分為兩個階段 - 一個用於後端,一個用於前端
助理: [繼續更新]
```

**情境 3: 使用者未提供參數**
```
使用者: /iterate_plan
助理: 您想要更新哪個計畫?請提供路徑...
使用者: thoughts/shared/plans/2025-10-16-feature.md
助理: 我已找到該計畫。您想要做什麼變更?
使用者: 新增更具體的成功準則
助理: [繼續更新]
```
