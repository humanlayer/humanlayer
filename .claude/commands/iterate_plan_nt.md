---
description: 透過深入研究和更新來迭代現有的實作計畫
model: opus
---

# 迭代實作計畫

你的任務是根據使用者回饋更新現有的實作計畫。你應該保持懷疑態度、徹底檢查，並確保變更植基於實際程式碼庫的現實狀況。

## 初始回應

當此指令被呼叫時：

1. **解析輸入以識別**：
   - 計畫檔案路徑（例如：`thoughts/shared/plans/2025-10-16-feature.md`）
   - 請求的變更/回饋

2. **處理不同的輸入情境**：

   **如果未提供計畫檔案**：
   ```
   我將協助你迭代現有的實作計畫。

   你想要更新哪個計畫？請提供計畫檔案的路徑（例如：`thoughts/shared/plans/2025-10-16-feature.md`）。

   提示：你可以使用 `ls -lt thoughts/shared/plans/ | head` 列出最近的計畫
   ```
   等待使用者輸入，然後重新檢查回饋。

   **如果提供計畫檔案但沒有回饋**：
   ```
   我已找到位於 [path] 的計畫。你想要做哪些變更？

   例如：
   - "新增遷移處理的階段"
   - "更新成功標準以包含效能測試"
   - "調整範圍以排除功能 X"
   - "將階段 2 拆分為兩個獨立階段"
   ```
   等待使用者輸入。

   **如果同時提供計畫檔案和回饋**：
   - 立即進入步驟 1
   - 不需要提出初步問題

## 處理步驟

### 步驟 1：閱讀並理解當前計畫

1. **完整閱讀現有計畫檔案**：
   - 使用 Read 工具時不要使用 limit/offset 參數
   - 理解當前的結構、階段和範圍
   - 記錄成功標準和實作方法

2. **理解請求的變更**：
   - 解析使用者想要新增/修改/移除的內容
   - 識別變更是否需要程式碼庫研究
   - 確定更新的範圍

### 步驟 2：必要時進行研究

**只有在變更需要新的技術理解時才產生研究任務。**

如果使用者的回饋需要理解新的程式碼模式或驗證假設：

1. **使用 TodoWrite 建立研究待辦清單**

2. **產生平行子任務進行研究**：
   為每種類型的研究使用正確的代理：

   **用於程式碼調查：**
   - **codebase-locator** - 尋找相關檔案
   - **codebase-analyzer** - 理解實作細節
   - **codebase-pattern-finder** - 尋找類似的模式

   **對目錄要極度具體**：
   - 在提示中包含完整的路徑上下文

3. **閱讀研究識別出的任何新檔案**：
   - 將它們完整讀入主要上下文
   - 與計畫需求交叉參照

4. 繼續之前**等待所有子任務完成**

### 步驟 3：呈現理解和方法

在進行變更之前，確認你的理解：

```
根據你的回饋，我理解你想要：
- [具體細節的變更 1]
- [具體細節的變更 2]

我的研究發現：
- [相關的程式碼模式或限制]
- [影響變更的重要發現]

我計畫透過以下方式更新計畫：
1. [要進行的具體修改]
2. [另一個修改]

這符合你的意圖嗎？
```

在繼續之前取得使用者確認。

### 步驟 4：更新計畫

1. **對現有計畫進行集中、精確的編輯**：
   - 使用 Edit 工具進行精確變更
   - 除非明確要求變更，否則維持現有結構
   - 保持所有 file:line 參照的準確性
   - 必要時更新成功標準

2. **確保一致性**：
   - 如果新增新階段，確保遵循現有模式
   - 如果修改範圍，更新「我們不做的事項」區段
   - 如果變更方法，更新「實作方法」區段
   - 維持自動化與手動成功標準之間的區別

3. **保持品質標準**：
   - 為新內容包含具體的檔案路徑和行號
   - 撰寫可衡量的成功標準
   - 使用 `make` 指令進行自動化驗證
   - 保持語言清晰且可操作

### 步驟 5：同步和審查

**呈現所做的變更**：
   ```
   我已更新位於 `thoughts/shared/plans/[filename].md` 的計畫

   所做的變更：
   - [具體變更 1]
   - [具體變更 2]

   更新後的計畫現在：
   - [關鍵改進]
   - [另一個改進]

   你需要任何進一步的調整嗎？
   ```

**準備好根據回饋進一步迭代**

## 重要指南

1. **保持懷疑**：
   - 不要盲目接受看似有問題的變更請求
   - 質疑模糊的回饋 - 要求澄清
   - 透過程式碼研究驗證技術可行性
   - 指出與現有計畫階段的潛在衝突

2. **保持精準**：
   - 進行精確編輯，而非全面改寫
   - 保留不需要變更的良好內容
   - 只研究特定變更所需的內容
   - 不要過度設計更新

3. **保持徹底**：
   - 在進行變更前閱讀整個現有計畫
   - 如果變更需要新的技術理解，研究程式碼模式
   - 確保更新的區段維持品質標準
   - 驗證成功標準仍然可衡量

4. **保持互動**：
   - 在進行變更前確認理解
   - 在執行前展示你計畫變更的內容
   - 允許路線修正
   - 不要在沒有溝通的情況下陷入研究

5. **追蹤進度**：
   - 如果複雜，使用 TodoWrite 追蹤更新任務
   - 完成研究時更新待辦事項
   - 完成時標記任務為完成

6. **不留未解問題**：
   - 如果請求的變更引發問題，請詢問
   - 立即進行研究或取得澄清
   - 不要在有未解決問題的情況下更新計畫
   - 每個變更都必須完整且可操作

## 成功標準指南

更新成功標準時，始終維持兩類別結構：

1. **自動化驗證**（可由執行代理執行）：
   - 可以執行的指令：`make test`、`npm run lint` 等
   - 應該存在的特定檔案
   - 程式碼編譯/型別檢查

2. **手動驗證**（需要人工測試）：
   - UI/UX 功能
   - 真實條件下的效能
   - 難以自動化的邊緣情況
   - 使用者驗收標準

## 子任務產生最佳實踐

產生研究子任務時：

1. **只在真正需要時產生** - 不要為簡單變更進行研究
2. **平行產生多個任務**以提高效率
3. **每個任務應該集中**在特定領域
4. **提供詳細說明**，包括：
   - 要搜尋的確切內容
   - 要關注的目錄
   - 要擷取的資訊
   - 預期的輸出格式
5. **在回應中請求特定的 file:line 參照**
6. **在綜合之前等待所有任務完成**
7. **驗證子任務結果** - 如果有問題，產生後續任務

## 範例互動流程

**情境 1：使用者預先提供所有內容**
```
User: /iterate_plan thoughts/shared/plans/2025-10-16-feature.md - add phase for error handling
Assistant: [讀取計畫，研究錯誤處理模式，更新計畫]
```

**情境 2：使用者只提供計畫檔案**
```
User: /iterate_plan thoughts/shared/plans/2025-10-16-feature.md
Assistant: 我已找到計畫。你想要做哪些變更？
User: Split Phase 2 into two phases - one for backend, one for frontend
Assistant: [繼續更新]
```

**情境 3：使用者未提供參數**
```
User: /iterate_plan
Assistant: 你想要更新哪個計畫？請提供路徑...
User: thoughts/shared/plans/2025-10-16-feature.md
Assistant: 我已找到計畫。你想要做哪些變更？
User: Add more specific success criteria to phase 4
Assistant: [繼續更新]
```
